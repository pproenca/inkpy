# InkPy Phases 6, 7, 8 Implementation Plan

> **Goal:** Complete the InkPy migration by implementing app infrastructure, integration layer, and final polish with TDD approach
>
> **Tech Stack:** Python 3.9+, ReactPy, Poga (Yoga layout), pytest
>
> **Reference:** Original Ink source at `ink/src/`
>
> **Prerequisites:** Phases 3, 4, 5 completed ✅

---

## Phase 6: App Infrastructure (Priority: HIGH)

### Task 6.1: App Context and useApp Hook ⬜

**Files:**
- `inkpy/inkpy/components/app_context.py`
- `inkpy/inkpy/hooks/use_app.py`
- `inkpy/tests/test_use_app.py`

**Reference:** `ink/src/components/AppContext.ts`, `src/hooks/use-app.ts`

**Step 1: Write failing tests**

```python
# test_use_app.py
import pytest
from reactpy import component, html
from inkpy.hooks.use_app import use_app
from inkpy.components.app_context import AppContext

def test_use_app_provides_exit():
    """Test that useApp hook provides exit function"""
    exit_called = []

    @component
    def TestApp():
        app = use_app()
        assert hasattr(app, 'exit')
        assert callable(app.exit)
        return html.div()

    # Test within AppContext
    # Will implement after ReactPy integration

def test_app_context_exit():
    """Test that exit function can be called"""
    exit_called = []

    def mock_exit(error=None):
        exit_called.append(error)

    context_value = {'exit': mock_exit}

    # Verify exit can be called with and without error
    context_value['exit']()
    assert len(exit_called) == 1
    assert exit_called[0] is None

    context_value['exit'](ValueError("test error"))
    assert len(exit_called) == 2
    assert isinstance(exit_called[1], ValueError)

def test_use_app_in_component():
    """Integration test for useApp hook"""
    # This will test the actual hook usage in a rendered component
    pass  # TODO: Implement after Task 6.4
```

**Step 2: Implement AppContext**

Create `inkpy/inkpy/components/app_context.py`:
- Create ReactPy context with default exit function
- Type hint for context value: `{'exit': Callable[[Optional[Exception]], None]}`

**Step 3: Implement useApp hook**

Create `inkpy/inkpy/hooks/use_app.py`:
- Import and use ReactPy's `use_context`
- Return the AppContext value

**Verification:**
```bash
cd inkpy && pytest tests/test_use_app.py -v
```

---

### Task 6.2: Stdout/Stderr Hooks and Contexts ⬜

**Files:**
- `inkpy/inkpy/components/stdout_context.py`
- `inkpy/inkpy/components/stderr_context.py`
- `inkpy/inkpy/hooks/use_stdout.py`
- `inkpy/inkpy/hooks/use_stderr.py`
- `inkpy/tests/test_std_hooks.py`

**Reference:** `ink/src/components/StdoutContext.ts`, `src/components/StderrContext.ts`, `src/hooks/use-stdout.ts`, `src/hooks/use-stderr.ts`

**Step 1: Write failing tests**

```python
# test_std_hooks.py
import pytest
import io
from reactpy import component
from inkpy.hooks.use_stdout import use_stdout
from inkpy.hooks.use_stderr import use_stderr

def test_use_stdout_provides_stream():
    """Test that useStdout provides stdout stream and write function"""
    @component
    def TestApp():
        stdout = use_stdout()
        assert hasattr(stdout, 'stdout')
        assert hasattr(stdout, 'write')
        assert callable(stdout.write)
        return None

    # Will test after integration

def test_stdout_write():
    """Test that stdout write function works"""
    buffer = io.StringIO()

    def write_fn(data):
        buffer.write(data)

    write_fn("Hello, World!")
    assert buffer.getvalue() == "Hello, World!"

def test_use_stderr_provides_stream():
    """Test that useStderr provides stderr stream"""
    @component
    def TestApp():
        stderr = use_stderr()
        assert hasattr(stderr, 'stderr')
        assert hasattr(stderr, 'write')
        assert callable(stderr.write)
        return None

def test_stderr_write():
    """Test that stderr write function works"""
    buffer = io.StringIO()

    def write_fn(data):
        buffer.write(data)

    write_fn("Error message")
    assert buffer.getvalue() == "Error message"
```

**Step 2: Implement StdoutContext**

Create `inkpy/inkpy/components/stdout_context.py`:
- Create ReactPy context
- Context value: `{'stdout': TextIO, 'write': Callable[[str], None]}`

**Step 3: Implement StderrContext**

Create `inkpy/inkpy/components/stderr_context.py`:
- Create ReactPy context
- Context value: `{'stderr': TextIO, 'write': Callable[[str], None]}`

**Step 4: Implement hooks**

Create hooks that use `use_context` to access the respective contexts.

**Verification:**
```bash
cd inkpy && pytest tests/test_std_hooks.py -v
```

---

### Task 6.3: Focus Management System ⬜

**Files:**
- `inkpy/inkpy/components/focus_context.py`
- `inkpy/inkpy/hooks/use_focus.py`
- `inkpy/inkpy/hooks/use_focus_manager.py`
- `inkpy/tests/test_focus.py`

**Reference:** `ink/src/components/FocusContext.ts`, `src/hooks/use-focus.ts`, `src/hooks/use-focus-manager.ts`

**Step 1: Write failing tests**

```python
# test_focus.py
import pytest
from reactpy import component
from inkpy.hooks.use_focus import use_focus
from inkpy.hooks.use_focus_manager import use_focus_manager
from inkpy.components.text import Text
from inkpy.components.box import Box

def test_focus_context_structure():
    """Test FocusContext provides required fields"""
    from inkpy.components.focus_context import FocusContext

    # Verify context has correct structure
    context_value = {
        'active_id': None,
        'add': lambda id, opts: None,
        'remove': lambda id: None,
        'activate': lambda id: None,
        'deactivate': lambda id: None,
        'enable_focus': lambda: None,
        'disable_focus': lambda: None,
        'focus_next': lambda: None,
        'focus_previous': lambda: None,
        'focus': lambda id: None,
    }

    for key in context_value.keys():
        assert key in context_value

def test_use_focus_returns_is_focused():
    """Test useFocus hook returns isFocused boolean"""
    @component
    def FocusableItem():
        focus = use_focus()
        assert hasattr(focus, 'is_focused')
        assert hasattr(focus, 'focus')
        assert isinstance(focus.is_focused, bool)
        return Text("Item")

def test_use_focus_with_auto_focus():
    """Test useFocus with autoFocus option"""
    @component
    def AutoFocusItem():
        focus = use_focus(auto_focus=True)
        return Text("Auto focused" if focus.is_focused else "Not focused")

def test_use_focus_with_custom_id():
    """Test useFocus with custom ID"""
    @component
    def CustomIdItem():
        focus = use_focus(id="my-custom-id")
        return Text("Item")

def test_focus_manager_navigation():
    """Test focus manager provides navigation functions"""
    @component
    def ManagerTest():
        manager = use_focus_manager()
        assert hasattr(manager, 'focus_next')
        assert hasattr(manager, 'focus_previous')
        assert hasattr(manager, 'enable_focus')
        assert hasattr(manager, 'disable_focus')
        return None

def test_focus_state_management():
    """Test focus state tracking"""
    # Simulate focus management
    focusables = []
    active_id = None

    def add_focusable(id, opts):
        focusables.append({'id': id, 'is_active': True, 'auto_focus': opts.get('auto_focus', False)})
        nonlocal active_id
        if not active_id and opts.get('auto_focus'):
            active_id = id

    def remove_focusable(id):
        nonlocal focusables, active_id
        focusables = [f for f in focusables if f['id'] != id]
        if active_id == id:
            active_id = None

    add_focusable('item1', {'auto_focus': True})
    assert active_id == 'item1'

    add_focusable('item2', {'auto_focus': False})
    assert active_id == 'item1'  # Should not change

    remove_focusable('item1')
    assert active_id is None
```

**Step 2: Implement FocusContext**

Create `inkpy/inkpy/components/focus_context.py`:
- Create ReactPy context
- Context value includes:
  - `active_id: Optional[str]`
  - `add(id: str, options: dict) -> None`
  - `remove(id: str) -> None`
  - `activate(id: str) -> None`
  - `deactivate(id: str) -> None`
  - `enable_focus() -> None`
  - `disable_focus() -> None`
  - `focus_next() -> None`
  - `focus_previous() -> None`
  - `focus(id: str) -> None`

**Step 3: Implement useFocus hook**

Create `inkpy/inkpy/hooks/use_focus.py`:
- Accept parameters: `is_active=True, auto_focus=False, id=None`
- Generate random ID if not provided
- Use `use_effect` to register/unregister with FocusContext
- Use `use_effect` to manage raw mode via `use_stdin`
- Return `{'is_focused': bool, 'focus': Callable}`

**Step 4: Implement useFocusManager hook**

Create `inkpy/inkpy/hooks/use_focus_manager.py`:
- Return FocusContext methods for external control
- Provide: `enable_focus`, `disable_focus`, `focus_next`, `focus_previous`, `focus`

**Verification:**
```bash
cd inkpy && pytest tests/test_focus.py -v
```

---

### Task 6.4: Main Ink Class ⬜

**Files:**
- `inkpy/inkpy/ink.py`
- `inkpy/inkpy/components/app.py` (App wrapper component)
- `inkpy/tests/test_ink.py`

**Reference:** `ink/src/ink.tsx`, `src/components/App.tsx`

**Step 1: Write failing tests**

```python
# test_ink.py
import pytest
import io
from inkpy.ink import Ink
from inkpy.components.text import Text
from inkpy.components.box import Box
from reactpy import component

class MockStdout:
    def __init__(self):
        self.buffer = io.StringIO()
        self.columns = 80
        self.rows = 24

    def write(self, data):
        self.buffer.write(data)

    def getvalue(self):
        return self.buffer.getvalue()

def test_ink_initialization():
    """Test Ink class can be initialized"""
    stdout = MockStdout()
    stdin = io.StringIO()
    stderr = MockStdout()

    ink = Ink(
        stdout=stdout,
        stdin=stdin,
        stderr=stderr,
        debug=False,
        exit_on_ctrl_c=True,
        patch_console=False,
    )

    assert ink is not None
    assert ink.is_unmounted == False

def test_ink_render():
    """Test Ink can render a component"""
    stdout = MockStdout()

    @component
    def App():
        return Text("Hello, World!")

    ink = Ink(
        stdout=stdout,
        stdin=io.StringIO(),
        stderr=MockStdout(),
        debug=True,
    )

    ink.render(App())

    # In debug mode, output should be written directly
    output = stdout.getvalue()
    assert "Hello, World!" in output

def test_ink_unmount():
    """Test Ink unmount cleans up properly"""
    stdout = MockStdout()

    @component
    def App():
        return Text("Test")

    ink = Ink(stdout=stdout, stdin=io.StringIO(), stderr=MockStdout())
    ink.render(App())
    ink.unmount()

    assert ink.is_unmounted == True

def test_ink_wait_until_exit():
    """Test waitUntilExit returns a promise"""
    ink = Ink(
        stdout=MockStdout(),
        stdin=io.StringIO(),
        stderr=MockStdout(),
    )

    exit_promise = ink.wait_until_exit()
    assert exit_promise is not None
    # Promise should resolve when unmounted
    ink.unmount()

def test_ink_calculate_layout():
    """Test layout calculation"""
    stdout = MockStdout()

    ink = Ink(stdout=stdout, stdin=io.StringIO(), stderr=MockStdout())

    # Should be able to calculate layout
    ink.calculate_layout()

    # Root node should have width set to terminal width
    assert ink.root_node.yoga_node is not None

def test_ink_max_fps_option():
    """Test maxFps option affects throttling"""
    ink1 = Ink(
        stdout=MockStdout(),
        stdin=io.StringIO(),
        stderr=MockStdout(),
        max_fps=30,
    )

    ink2 = Ink(
        stdout=MockStdout(),
        stdin=io.StringIO(),
        stderr=MockStdout(),
        max_fps=60,
    )

    # Both should initialize without error
    assert ink1 is not None
    assert ink2 is not None
```

**Step 2: Implement App wrapper component**

Create `inkpy/inkpy/components/app.py`:
- Port from `ink/src/components/App.tsx`
- Manage focus state
- Provide all contexts (App, Stdin, Stdout, Stderr, Focus)
- Handle Tab/Shift+Tab for focus navigation
- Handle Ctrl+C exit
- Manage raw mode reference counting
- Handle stdin events

Key responsibilities:
- Context providers for all app contexts
- Focus management state
- Raw mode handling
- Keyboard input handling (Tab, Shift+Tab, Esc, Ctrl+C)
- Error boundary (if ReactPy supports it)

**Step 3: Implement Ink class**

Create `inkpy/inkpy/ink.py`:
- Port from `ink/src/ink.tsx`

Constructor options:
- `stdout: TextIO`
- `stdin: TextIO`
- `stderr: TextIO`
- `debug: bool = False`
- `exit_on_ctrl_c: bool = True`
- `patch_console: bool = True`
- `max_fps: int = 30`
- `incremental_rendering: bool = False`

Instance properties:
- `root_node: DOMElement` (ink-root)
- `is_unmounted: bool`
- `last_output: str`
- `last_output_height: int`
- `last_terminal_width: int`

Methods:
- `__init__(options)` - Initialize with options
- `render(node: Component)` - Render a ReactPy component
- `calculate_layout()` - Calculate Yoga layout for root node
- `on_render()` - Callback when layout changes (renders to output)
- `unmount(error: Optional[Exception])` - Clean up and exit
- `wait_until_exit() -> Awaitable` - Async wait for app exit
- `clear()` - Clear output
- `get_terminal_width() -> int` - Get stdout columns

Integration with ReactPy:
- Use ReactPy's rendering system to mount the App component
- Connect to layout engine via DOM nodes
- Trigger re-renders on state changes

**Step 4: Integrate with ReactPy reconciler**

Note: ReactPy has its own reconciler. We need to:
1. Bridge ReactPy VDOM to our DOM node system
2. Connect ReactPy component updates to layout recalculation
3. Ensure rendering pipeline is triggered on updates

This may require:
- Custom ReactPy backend in `inkpy/backend/tui_backend.py`
- VDOM to DOM node conversion
- Layout calculation hooks

**Verification:**
```bash
cd inkpy && pytest tests/test_ink.py -v
```

---

### Task 6.5: Render Function (Public API) ⬜

**Files:**
- `inkpy/inkpy/render.py`
- `inkpy/tests/test_render.py`

**Reference:** `ink/src/render.ts`

**Step 1: Write failing tests**

```python
# test_render.py
import pytest
import sys
import io
from inkpy.render import render
from inkpy.components.text import Text
from inkpy.components.box import Box
from reactpy import component

def test_render_returns_instance():
    """Test render function returns Instance object"""
    @component
    def App():
        return Text("Test")

    instance = render(App(), stdout=io.StringIO(), stdin=io.StringIO(), stderr=io.StringIO())

    assert instance is not None
    assert hasattr(instance, 'rerender')
    assert hasattr(instance, 'unmount')
    assert hasattr(instance, 'wait_until_exit')
    assert hasattr(instance, 'clear')

    instance.unmount()

def test_render_with_stdout_option():
    """Test render with custom stdout"""
    buffer = io.StringIO()
    buffer.columns = 80
    buffer.rows = 24

    @component
    def App():
        return Text("Hello")

    instance = render(App(), stdout=buffer, debug=True)

    # Should write to custom stdout
    instance.unmount()

def test_render_default_options():
    """Test render uses default options"""
    @component
    def App():
        return Text("Test")

    # Should use sys.stdout by default
    instance = render(App(), stdout=io.StringIO(), stdin=io.StringIO())
    instance.unmount()

def test_instance_rerender():
    """Test instance.rerender updates the component"""
    @component
    def App():
        return Text("Initial")

    instance = render(App(), stdout=io.StringIO(), stdin=io.StringIO(), debug=True)

    @component
    def NewApp():
        return Text("Updated")

    instance.rerender(NewApp())
    instance.unmount()

def test_instance_clear():
    """Test instance.clear clears output"""
    @component
    def App():
        return Text("Test")

    instance = render(App(), stdout=io.StringIO(), stdin=io.StringIO())
    instance.clear()
    instance.unmount()

def test_render_singleton_per_stdout():
    """Test render creates singleton Ink instance per stdout"""
    stdout1 = io.StringIO()
    stdout1.columns = 80

    @component
    def App():
        return Text("Test")

    instance1 = render(App(), stdout=stdout1)
    instance2 = render(App(), stdout=stdout1)

    # Should reuse same Ink instance
    instance1.unmount()
```

**Step 2: Implement render function**

Create `inkpy/inkpy/render.py`:

```python
from typing import Optional, TextIO, Callable
import sys
from inkpy.ink import Ink
from inkpy.instances import instances

class Instance:
    """Represents a rendered Ink application instance"""

    def __init__(self, ink: Ink):
        self._ink = ink

    def rerender(self, node):
        """Re-render with a new component tree"""
        self._ink.render(node)

    def unmount(self, error: Optional[Exception] = None):
        """Unmount the application"""
        self._ink.unmount(error)

    async def wait_until_exit(self):
        """Wait until the application exits"""
        return await self._ink.wait_until_exit()

    def clear(self):
        """Clear the output"""
        self._ink.clear()

    def cleanup(self):
        """Remove instance from registry"""
        instances.delete(self._ink.options['stdout'])

def render(
    node,
    stdout: Optional[TextIO] = None,
    stdin: Optional[TextIO] = None,
    stderr: Optional[TextIO] = None,
    debug: bool = False,
    exit_on_ctrl_c: bool = True,
    patch_console: bool = True,
    max_fps: int = 30,
    incremental_rendering: bool = False,
) -> Instance:
    """
    Mount a component and render the output.

    Args:
        node: ReactPy component to render
        stdout: Output stream (default: sys.stdout)
        stdin: Input stream (default: sys.stdin)
        stderr: Error stream (default: sys.stderr)
        debug: Enable debug mode
        exit_on_ctrl_c: Exit on Ctrl+C
        patch_console: Patch console methods
        max_fps: Maximum frames per second
        incremental_rendering: Enable incremental rendering

    Returns:
        Instance object with rerender, unmount, wait_until_exit, clear methods
    """
    options = {
        'stdout': stdout or sys.stdout,
        'stdin': stdin or sys.stdin,
        'stderr': stderr or sys.stderr,
        'debug': debug,
        'exit_on_ctrl_c': exit_on_ctrl_c,
        'patch_console': patch_console,
        'max_fps': max_fps,
        'incremental_rendering': incremental_rendering,
    }

    # Get or create Ink instance for this stdout
    ink = get_instance(options['stdout'], lambda: Ink(**options))
    ink.render(node)

    return Instance(ink)

def get_instance(stdout: TextIO, factory: Callable[[], Ink]) -> Ink:
    """Get or create Ink instance for stdout stream"""
    instance = instances.get(stdout)
    if instance is None:
        instance = factory()
        instances.set(stdout, instance)
    return instance
```

**Step 3: Create instances registry**

Create `inkpy/inkpy/instances.py`:

```python
from typing import Dict, Optional, TextIO
from weakref import WeakValueDictionary

class Instances:
    """Registry of Ink instances per stdout stream"""

    def __init__(self):
        self._instances: Dict[int, 'Ink'] = {}

    def get(self, stdout: TextIO) -> Optional['Ink']:
        """Get Ink instance for stdout"""
        return self._instances.get(id(stdout))

    def set(self, stdout: TextIO, ink: 'Ink'):
        """Register Ink instance for stdout"""
        self._instances[id(stdout)] = ink

    def delete(self, stdout: TextIO):
        """Remove Ink instance for stdout"""
        self._instances.pop(id(stdout), None)

instances = Instances()
```

**Verification:**
```bash
cd inkpy && pytest tests/test_render.py -v
```

---

## Phase 7: Integration & End-to-End (Priority: HIGH)

### Task 7.1: DOM Node System ⬜

**Files:**
- `inkpy/inkpy/dom.py`
- `inkpy/tests/test_dom.py`

**Reference:** `ink/src/dom.ts`

**Step 1: Write failing tests**

```python
# test_dom.py
import pytest
from inkpy.dom import (
    create_node,
    create_text_node,
    append_child_node,
    remove_child_node,
    insert_before_node,
    set_attribute,
    set_style,
    DOMElement,
    TextNode,
)

def test_create_node():
    """Test creating a DOM element node"""
    node = create_node('ink-box')

    assert node.node_name == 'ink-box'
    assert node.yoga_node is not None
    assert node.style == {}
    assert node.attributes == {}
    assert node.child_nodes == []
    assert node.parent_node is None

def test_create_text_node():
    """Test creating a text node"""
    text_node = create_text_node("Hello, World!")

    assert text_node.node_name == '#text'
    assert text_node.node_value == "Hello, World!"
    assert text_node.yoga_node is None
    assert text_node.parent_node is None

def test_append_child_node():
    """Test appending child nodes"""
    parent = create_node('ink-box')
    child1 = create_node('ink-text')
    child2 = create_node('ink-text')

    append_child_node(parent, child1)
    assert len(parent.child_nodes) == 1
    assert child1.parent_node == parent

    append_child_node(parent, child2)
    assert len(parent.child_nodes) == 2
    assert child2.parent_node == parent

def test_remove_child_node():
    """Test removing child nodes"""
    parent = create_node('ink-box')
    child = create_node('ink-text')

    append_child_node(parent, child)
    assert len(parent.child_nodes) == 1

    remove_child_node(parent, child)
    assert len(parent.child_nodes) == 0
    assert child.parent_node is None

def test_insert_before_node():
    """Test inserting node before another"""
    parent = create_node('ink-box')
    child1 = create_node('ink-text')
    child2 = create_node('ink-text')
    child3 = create_node('ink-text')

    append_child_node(parent, child1)
    append_child_node(parent, child3)
    insert_before_node(parent, child2, child3)

    assert parent.child_nodes == [child1, child2, child3]

def test_set_attribute():
    """Test setting node attributes"""
    node = create_node('ink-box')

    set_attribute(node, 'id', 'my-box')
    assert node.attributes['id'] == 'my-box'

    set_attribute(node, 'data-test', 'value')
    assert node.attributes['data-test'] == 'value'

def test_set_style():
    """Test setting node styles"""
    node = create_node('ink-box')

    style = {
        'flexDirection': 'row',
        'padding': 2,
        'backgroundColor': 'blue',
    }

    set_style(node, style)
    assert node.style == style

def test_ink_text_measure_function():
    """Test that ink-text nodes have measure function"""
    text_node = create_node('ink-text')

    # Should have measure function set on yoga node
    assert text_node.yoga_node is not None
    # Yoga node should have measure function

def test_yoga_node_tree_sync():
    """Test that Yoga tree stays in sync with DOM tree"""
    parent = create_node('ink-box')
    child1 = create_node('ink-box')
    child2 = create_node('ink-box')

    append_child_node(parent, child1)
    append_child_node(parent, child2)

    # Yoga tree should match DOM tree
    assert parent.yoga_node.get_child_count() == 2

    remove_child_node(parent, child1)
    assert parent.yoga_node.get_child_count() == 1

def test_text_node_value_update():
    """Test updating text node value"""
    text_node = create_text_node("Initial")

    # Should be able to update value
    # This will mark parent yoga node as dirty for remeasurement
    text_node.node_value = "Updated"
    assert text_node.node_value == "Updated"
```

**Step 2: Implement DOM node system**

Create `inkpy/inkpy/dom.py`:

Port from `ink/src/dom.ts`:

```python
from typing import Optional, List, Dict, Any, Union, Callable
from inkpy.layout.yoga_node import YogaNode
from inkpy.measure_text import measure_text
from inkpy.wrap_text import wrap_text

# Type definitions
NodeName = Union[str, type]  # 'ink-root', 'ink-box', 'ink-text', 'ink-virtual-text', '#text'

class DOMNode:
    """Base class for DOM nodes"""
    def __init__(self):
        self.node_name: str = ''
        self.parent_node: Optional['DOMElement'] = None
        self.yoga_node: Optional[YogaNode] = None
        self.style: Dict[str, Any] = {}
        self.internal_static: bool = False

class DOMElement(DOMNode):
    """DOM element node"""
    def __init__(self, node_name: str):
        super().__init__()
        self.node_name = node_name
        self.attributes: Dict[str, Any] = {}
        self.child_nodes: List[Union['DOMElement', 'TextNode']] = []
        self.internal_transform: Optional[Callable] = None
        self.internal_accessibility: Dict[str, Any] = {}
        self.is_static_dirty: bool = False
        self.static_node: Optional['DOMElement'] = None
        self.on_compute_layout: Optional[Callable] = None
        self.on_render: Optional[Callable] = None
        self.on_immediate_render: Optional[Callable] = None

class TextNode(DOMNode):
    """Text node"""
    def __init__(self, value: str):
        super().__init__()
        self.node_name = '#text'
        self.node_value = value

# Factory functions
def create_node(node_name: str) -> DOMElement:
    """Create a DOM element node"""
    node = DOMElement(node_name)

    # Create Yoga node (except for virtual text)
    if node_name != 'ink-virtual-text':
        node.yoga_node = YogaNode()

    # Set measure function for text nodes
    if node_name == 'ink-text':
        node.yoga_node.set_measure_func(lambda width, height: measure_text_node(node, width, height))

    return node

def create_text_node(text: str) -> TextNode:
    """Create a text node"""
    if not isinstance(text, str):
        text = str(text)
    return TextNode(text)

def append_child_node(parent: DOMElement, child: Union[DOMElement, TextNode]):
    """Append a child node to parent"""
    # Remove from previous parent if exists
    if child.parent_node:
        remove_child_node(child.parent_node, child)

    child.parent_node = parent
    parent.child_nodes.append(child)

    # Update Yoga tree
    if child.yoga_node and parent.yoga_node:
        parent.yoga_node.insert_child(child.yoga_node, parent.yoga_node.get_child_count())

    # Mark text nodes as dirty
    if parent.node_name in ('ink-text', 'ink-virtual-text'):
        mark_node_as_dirty(parent)

def insert_before_node(parent: DOMElement, new_child: Union[DOMElement, TextNode], before_child: Union[DOMElement, TextNode]):
    """Insert new_child before before_child"""
    if new_child.parent_node:
        remove_child_node(new_child.parent_node, new_child)

    new_child.parent_node = parent

    try:
        index = parent.child_nodes.index(before_child)
        parent.child_nodes.insert(index, new_child)

        if new_child.yoga_node and parent.yoga_node:
            parent.yoga_node.insert_child(new_child.yoga_node, index)
    except ValueError:
        # before_child not found, append instead
        parent.child_nodes.append(new_child)
        if new_child.yoga_node and parent.yoga_node:
            parent.yoga_node.insert_child(new_child.yoga_node, parent.yoga_node.get_child_count())

    if parent.node_name in ('ink-text', 'ink-virtual-text'):
        mark_node_as_dirty(parent)

def remove_child_node(parent: DOMElement, child: Union[DOMElement, TextNode]):
    """Remove child node from parent"""
    if child.yoga_node and parent.yoga_node:
        parent.yoga_node.remove_child(child.yoga_node)

    child.parent_node = None

    try:
        parent.child_nodes.remove(child)
    except ValueError:
        pass

    if parent.node_name in ('ink-text', 'ink-virtual-text'):
        mark_node_as_dirty(parent)

def set_attribute(node: DOMElement, key: str, value: Any):
    """Set attribute on node"""
    if key == 'internal_accessibility':
        node.internal_accessibility = value
    else:
        node.attributes[key] = value

def set_style(node: Union[DOMElement, TextNode], style: Dict[str, Any]):
    """Set style on node"""
    node.style = style

# Helper functions
def measure_text_node(node: Union[DOMElement, TextNode], width: float, height: float) -> Dict[str, float]:
    """Measure text node dimensions"""
    # Get text content
    if isinstance(node, TextNode):
        text = node.node_value
    else:
        text = squash_text_nodes(node)

    dimensions = measure_text(text)

    # Text fits, no need to wrap
    if dimensions['width'] <= width:
        return dimensions

    # Handle edge case when width < 1px
    if dimensions['width'] >= 1 and 0 < width < 1:
        return dimensions

    # Wrap text
    text_wrap = node.style.get('textWrap', 'wrap')
    wrapped_text = wrap_text(text, width, text_wrap)

    return measure_text(wrapped_text)

def squash_text_nodes(node: DOMElement) -> str:
    """Concatenate all text node children"""
    text_parts = []

    for child in node.child_nodes:
        if isinstance(child, TextNode):
            text_parts.append(child.node_value)
        elif isinstance(child, DOMElement):
            text_parts.append(squash_text_nodes(child))

    return ''.join(text_parts)

def find_closest_yoga_node(node: Optional[Union[DOMElement, TextNode]]) -> Optional[YogaNode]:
    """Find closest parent with Yoga node"""
    if not node or not node.parent_node:
        return None

    if node.yoga_node:
        return node.yoga_node

    return find_closest_yoga_node(node.parent_node)

def mark_node_as_dirty(node: Optional[Union[DOMElement, TextNode]]):
    """Mark closest Yoga node as dirty for remeasurement"""
    yoga_node = find_closest_yoga_node(node)
    if yoga_node:
        yoga_node.mark_dirty()
```

**Step 3: Implement helper modules if not already present**

Ensure these exist:
- `inkpy/inkpy/measure_text.py` - Text measurement
- `inkpy/inkpy/wrap_text.py` - Text wrapping

**Verification:**
```bash
cd inkpy && pytest tests/test_dom.py -v
```

---

### Task 7.2: ReactPy Backend Integration ⬜

**Files:**
- `inkpy/inkpy/backend/tui_backend.py` (enhance existing)
- `inkpy/tests/test_tui_backend.py`

**Goal:** Bridge ReactPy VDOM to our DOM node system and connect to layout/rendering

**Step 1: Write failing tests**

```python
# test_tui_backend.py
import pytest
from reactpy import component, html
from inkpy.backend.tui_backend import TUIBackend
from inkpy.components.box import Box
from inkpy.components.text import Text

def test_backend_initialization():
    """Test TUI backend can be initialized"""
    backend = TUIBackend()
    assert backend is not None

def test_backend_mounts_component():
    """Test backend can mount a component"""
    @component
    def App():
        return Box(Text("Hello"))

    backend = TUIBackend()
    root = backend.mount(App())

    assert root is not None
    assert root.node_name == 'ink-root'

def test_backend_creates_dom_nodes():
    """Test backend creates proper DOM nodes from VDOM"""
    @component
    def App():
        return Box(Text("Test"))

    backend = TUIBackend()
    root = backend.mount(App())

    # Should have child nodes for Box and Text
    assert len(root.child_nodes) > 0

def test_backend_handles_updates():
    """Test backend handles component updates"""
    counter = [0]

    @component
    def App():
        return Text(f"Count: {counter[0]}")

    backend = TUIBackend()
    root = backend.mount(App())

    # Update component
    counter[0] = 1
    backend.update()

    # DOM should reflect new count

def test_backend_calculates_layout():
    """Test backend triggers layout calculation"""
    @component
    def App():
        return Box(Text("Test"))

    backend = TUIBackend()
    root = backend.mount(App())

    # Should be able to calculate layout
    backend.calculate_layout(width=80)

    # Root should have computed layout
    assert root.yoga_node.get_computed_layout() is not None
```

**Step 2: Implement TUI backend**

Enhance `inkpy/inkpy/backend/tui_backend.py`:

This is the most complex task. The backend needs to:
1. Mount ReactPy components
2. Convert ReactPy VDOM to our DOM nodes
3. Handle component updates
4. Trigger layout recalculation
5. Trigger rendering

Key methods:
- `mount(component) -> DOMElement` - Mount root component
- `update()` - Handle updates
- `unmount()` - Clean up
- `calculate_layout(width: int)` - Calculate Yoga layout
- `render() -> str` - Render to string

**Note:** This requires deep ReactPy integration. May need to use ReactPy's internal APIs or create a custom renderer.

**Verification:**
```bash
cd inkpy && pytest tests/test_tui_backend.py -v
```

---

### Task 7.3: Counter Example (E2E Test) ⬜

**Files:**
- `inkpy/examples/counter.py`
- `inkpy/tests/test_counter_e2e.py`

**Step 1: Write E2E test**

```python
# test_counter_e2e.py
import pytest
import asyncio
from examples.counter import Counter

@pytest.mark.asyncio
async def test_counter_increments():
    """Test that counter increments over time"""
    # This will be a simple smoke test
    # Full E2E testing may require terminal emulation
    pass
```

**Step 2: Implement counter example**

Create `inkpy/examples/counter.py`:

```python
#!/usr/bin/env python3
"""
Counter Example - Demonstrates async state updates
"""
import asyncio
from reactpy import component, use_state, use_effect
from inkpy import render
from inkpy.components import Box, Text

@component
def Counter():
    count, set_count = use_state(0)

    @use_effect(dependencies=[])
    async def start_timer():
        while True:
            await asyncio.sleep(1)
            set_count(lambda c: c + 1)

    return Box(
        Text(f"Count: {count}", color="green", bold=True),
        border_style="round",
        padding=1,
    )

if __name__ == "__main__":
    instance = render(Counter())
    try:
        asyncio.run(instance.wait_until_exit())
    except KeyboardInterrupt:
        instance.unmount()
```

**Step 3: Manual verification**

```bash
cd inkpy && python examples/counter.py
```

Expected: Counter increments every second, displayed in a rounded border box.

---

### Task 7.4: Interactive Example (E2E Test) ⬜

**Files:**
- `inkpy/examples/interactive.py`
- `inkpy/tests/test_interactive_e2e.py`

**Step 1: Write E2E test**

```python
# test_interactive_e2e.py
import pytest
from examples.interactive import SelectList

def test_interactive_example_loads():
    """Smoke test that interactive example can load"""
    # Full E2E testing requires terminal emulation
    pass
```

**Step 2: Implement interactive example**

Create `inkpy/examples/interactive.py`:

```python
#!/usr/bin/env python3
"""
Interactive Example - Demonstrates keyboard navigation and focus
"""
from reactpy import component, use_state
from inkpy import render
from inkpy.components import Box, Text
from inkpy.hooks import use_input, use_app

@component
def SelectList():
    items = ["Option 1", "Option 2", "Option 3", "Exit"]
    selected, set_selected = use_state(0)
    app = use_app()

    def handle_input(input_str, key):
        if key.up_arrow:
            set_selected(lambda s: max(0, s - 1))
        elif key.down_arrow:
            set_selected(lambda s: min(len(items) - 1, s + 1))
        elif key.return_key:
            if selected == len(items) - 1:  # Exit option
                app.exit()

    use_input(handle_input)

    return Box(
        [
            Text(
                f"{'> ' if i == selected else '  '}{item}",
                color="green" if i == selected else "white",
                bold=i == selected,
            )
            for i, item in enumerate(items)
        ],
        flex_direction="column",
        border_style="single",
        padding=1,
    )

if __name__ == "__main__":
    instance = render(SelectList())
    try:
        import asyncio
        asyncio.run(instance.wait_until_exit())
    except KeyboardInterrupt:
        instance.unmount()
```

**Step 3: Manual verification**

```bash
cd inkpy && python examples/interactive.py
```

Expected: Menu with arrow key navigation, Enter to select, highlighted selection.

---

### Task 7.5: Hello World Example ⬜

**Files:**
- `inkpy/examples/hello_world.py`

**Step 1: Create minimal example**

```python
#!/usr/bin/env python3
"""
Hello World - Simplest InkPy example
"""
from reactpy import component
from inkpy import render
from inkpy.components import Text

@component
def App():
    return Text("Hello, World!", color="green", bold=True)

if __name__ == "__main__":
    render(App())
```

**Step 2: Manual verification**

```bash
cd inkpy && python examples/hello_world.py
```

Expected: "Hello, World!" in green bold text.

---

## Phase 8: Documentation & Polish (Priority: MEDIUM)

### Task 8.1: Public API Exports ⬜

**Files:**
- `inkpy/inkpy/__init__.py`

**Step 1: Define public API**

Create `inkpy/inkpy/__init__.py`:

```python
"""
InkPy - React for CLIs in Python
"""

__version__ = "0.1.0"

# Main render function
from inkpy.render import render

# Components
from inkpy.components.box import Box
from inkpy.components.text import Text
from inkpy.components.static import Static
from inkpy.components.newline import Newline
from inkpy.components.spacer import Spacer
from inkpy.components.transform import Transform

# Hooks
from inkpy.hooks.use_app import use_app
from inkpy.hooks.use_input import use_input
from inkpy.hooks.use_stdin import use_stdin
from inkpy.hooks.use_stdout import use_stdout
from inkpy.hooks.use_stderr import use_stderr
from inkpy.hooks.use_focus import use_focus
from inkpy.hooks.use_focus_manager import use_focus_manager

__all__ = [
    # Core
    'render',

    # Components
    'Box',
    'Text',
    'Static',
    'Newline',
    'Spacer',
    'Transform',

    # Hooks
    'use_app',
    'use_input',
    'use_stdin',
    'use_stdout',
    'use_stderr',
    'use_focus',
    'use_focus_manager',
]
```

**Verification:** Import test

```bash
cd inkpy && python -c "from inkpy import render, Box, Text; print('OK')"
```

---

### Task 8.2: API Documentation ⬜

**Files:**
- `inkpy/docs/api.md`

**Step 1: Create API documentation**

Structure:
1. **render()** - Main entry point
2. **Components**
   - Box
   - Text
   - Static
   - Newline
   - Spacer
   - Transform
3. **Hooks**
   - use_app
   - use_input
   - use_stdin
   - use_stdout
   - use_stderr
   - use_focus
   - use_focus_manager
4. **Types** - Style properties, options

Include:
- Function signatures
- Parameter descriptions
- Return types
- Usage examples
- Links to examples

---

### Task 8.3: README ⬜

**Files:**
- `inkpy/README.md`

**Step 1: Create README**

Sections:
1. **Introduction** - What is InkPy?
2. **Installation** - `pip install -e .`
3. **Quick Start** - Hello World example
4. **Features** - Bullet list
5. **Examples** - Links to examples/
6. **Documentation** - Link to docs/api.md
7. **Testing** - How to run tests
8. **Development** - Contributing guide
9. **License** - MIT
10. **Acknowledgments** - Credit to Ink

---

### Task 8.4: Type Hints ⬜

**Files:** All `inkpy/inkpy/**/*.py`

**Step 1: Add type hints to all modules**

Priority order:
1. Public API (render, components, hooks)
2. Internal systems (dom, ink, renderer)
3. Utilities

Use:
- `from typing import Optional, List, Dict, Union, Callable, Any`
- Type hint all function parameters
- Type hint return values
- Use `# type: ignore` sparingly for complex cases

**Step 2: Add py.typed marker**

Create `inkpy/inkpy/py.typed` (empty file) to indicate type hint support.

**Step 3: Run mypy**

```bash
cd inkpy && mypy inkpy/
```

Fix any type errors.

---

### Task 8.5: Integration Testing Suite ⬜

**Files:**
- `inkpy/tests/test_integration.py`

**Step 1: Create integration tests**

Test scenarios:
1. Render static app
2. Render app with state updates
3. Handle user input
4. Focus navigation
5. Multi-component layout
6. Static + dynamic content
7. Borders and colors
8. Text wrapping

Example:

```python
# test_integration.py
import pytest
from reactpy import component, use_state
from inkpy import render, Box, Text
import io

def test_render_simple_app():
    """Integration test: render simple app"""
    @component
    def App():
        return Box(Text("Hello, World!"))

    stdout = io.StringIO()
    stdout.columns = 80
    stdout.rows = 24

    instance = render(App(), stdout=stdout, debug=True)
    output = stdout.getvalue()

    assert "Hello, World!" in output
    instance.unmount()

def test_render_with_state():
    """Integration test: render app with state"""
    @component
    def Counter():
        count, set_count = use_state(0)

        return Box(Text(f"Count: {count}"))

    stdout = io.StringIO()
    stdout.columns = 80

    instance = render(Counter(), stdout=stdout, debug=True)
    # Should render with count 0
    instance.unmount()

def test_layout_calculation():
    """Integration test: layout is calculated"""
    @component
    def App():
        return Box(
            Box(Text("Left"), flex=1),
            Box(Text("Right"), flex=1),
            flex_direction="row",
        )

    stdout = io.StringIO()
    stdout.columns = 80

    instance = render(App(), stdout=stdout, debug=True)
    # Should render side-by-side
    instance.unmount()
```

**Verification:**

```bash
cd inkpy && pytest tests/test_integration.py -v
```

---

## Summary

### Task Breakdown

**Phase 6: App Infrastructure (5 tasks)**
1. Task 6.1: App Context and useApp Hook
2. Task 6.2: Stdout/Stderr Hooks and Contexts
3. Task 6.3: Focus Management System
4. Task 6.4: Main Ink Class
5. Task 6.5: Render Function

**Phase 7: Integration & End-to-End (5 tasks)**
1. Task 7.1: DOM Node System
2. Task 7.2: ReactPy Backend Integration
3. Task 7.3: Counter Example
4. Task 7.4: Interactive Example
5. Task 7.5: Hello World Example

**Phase 8: Documentation & Polish (5 tasks)**
1. Task 8.1: Public API Exports
2. Task 8.2: API Documentation
3. Task 8.3: README
4. Task 8.4: Type Hints
5. Task 8.5: Integration Testing Suite

### Total: 15 tasks

### Estimated Timeline

| Phase | Tasks | Estimated Time |
|-------|-------|----------------|
| Phase 6 | 5 tasks | 6-8 hours |
| Phase 7 | 5 tasks | 8-10 hours |
| Phase 8 | 5 tasks | 3-4 hours |
| **Total** | **15 tasks** | **17-22 hours** |

### Critical Path

1. **Task 7.1** (DOM System) - Foundational for everything
2. **Task 6.4** (Ink Class) - Core infrastructure
3. **Task 7.2** (ReactPy Backend) - Bridges components to rendering
4. **Task 6.5** (Render Function) - Public API
5. **Task 7.3-7.5** (Examples) - Validation
6. **Phase 8** - Polish and documentation

### Key Dependencies

- Task 6.4 depends on 6.1, 6.2, 6.3 (all contexts)
- Task 7.2 depends on 7.1 (DOM system)
- Task 6.5 depends on 6.4 (Ink class)
- Tasks 7.3-7.5 depend on 6.5 (render function)
- Phase 8 can run in parallel with late Phase 7

### Risk Areas

1. **ReactPy Integration (Task 7.2)** - Most complex, may need ReactPy deep dive
2. **Async/Event Loop** - ReactPy async vs Ink's sync rendering
3. **Focus Management** - Complex state management across components
4. **Testing E2E** - Terminal emulation is challenging

### Success Criteria

- ✅ All unit tests pass
- ✅ Counter example runs and increments
- ✅ Interactive example responds to arrow keys
- ✅ Hello World displays correctly
- ✅ No linter errors
- ✅ Type hints throughout
- ✅ Documentation complete

---

## Next Steps

Ready to begin Phase 6? Start with:

**Recommended Order:**
1. Task 7.1 (DOM System) - Foundation
2. Task 6.1 (App Context) - Simple context
3. Task 6.2 (Stdout/Stderr) - Simple contexts
4. Task 6.3 (Focus Management) - Complex context
5. Task 6.4 (Ink Class) - Integration
6. Task 6.5 (Render Function) - Public API
7. Task 7.2 (Backend Integration) - Critical integration
8. Tasks 7.3-7.5 (Examples) - Validation
9. Phase 8 (Documentation) - Polish

To execute: Reference `execution-workflow.mdc` and start with Task 7.1.
